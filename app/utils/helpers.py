import imghdr
import os
import re
from datetime import datetime
from functools import wraps
from urllib.parse import urlparse

import boto3
from flask import flash, redirect, session, url_for
from werkzeug.utils import secure_filename

from app.models import User


# Login required
def login_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if "user_id" not in session:
            return redirect(url_for("auth.login"))
        return f(*args, **kwargs)

    return decorated_function


# Logout required
def logout_required(func):
    @wraps(func)
    def decorated_function(*args, **kwargs):
        if session.get("user_id"):
            flash("You are already authenticated.", "info")
            return redirect(url_for("main.feed"))
        return func(*args, **kwargs)

    return decorated_function


# """ EMAIL VERIFICATION """
# def generate_token(email):
#     serializer = URLSafeTimedSerializer(current_app.config["SECRET_KEY"])
#     return serializer.dumps(email, salt=current_app.config["SECURITY_PASSWORD_SALT"])


# def confirm_token(token, expiration=3600):
#     serializer = URLSafeTimedSerializer(current_app.config["SECRET_KEY"])
#     try:
#         email = serializer.loads(
#             token, salt=current_app.config["SECURITY_PASSWORD_SALT"], max_age=expiration
#         )
#         return email
#     except Exception:
#         return False

# def send_email(to, subject, template):
#     from app.extensions import dbmail
#     msg = Message(
#         subject,
#         recipients=[to],
#         html=template,
#         sender=current_app.config["MAIL_DEFAULT_SENDER"],
#     )
#     mail.send(msg)


def array_to_str(array):
    return ",".join(array)


def validate_image(stream):
    header = stream.read(512)
    stream.seek(0)
    format = imghdr.what(None, header)
    if not format:
        return None
    return "." + (format if format != "jpeg" else "jpg")



def create_notification_message(notification):
    sender_name = f"{notification.sender.name} {notification.sender.surname}"

    match notification.notification_type.value:
        case "friend_request":
            return f"{sender_name} sent you a friend request"
        case "friend_accepted":
            return f"{sender_name} accepted your friend request"
        case "post_like":
            return f"{sender_name} liked your post"
        case "post_comment":
            return f"{sender_name} commented on your post"
        case "post_share":
            return f"{sender_name} shared your post"
        case "comment_like":
            return f"{sender_name} liked your comment"
        case _:
            return f"New notification from {sender_name}"


def create_notification_link(notification):
    match notification.notification_type.value:
        case "friend_request":
            return "/friends/requests"
        case "friend_accepted":
            return f"/profiles/{notification.sender.username}"
        case "post_like":
            return f"/posts/{notification.post_id}"
        case "post_comment":
            return f"/posts/{notification.post_id}#comment-{notification.comment_id}"
        case "post_share":
            return f"/posts/{notification.post_id}"
        case "comment_like":
            return f"/posts/{notification.post_id}#comment-{notification.comment_id}"
        case _:
            return "#"


# Generated by Claude AI
def process_hashtags(text):
    """
    Process text to convert hashtags into clickable links.
    Hashtags must:
    - Start with #
    - Contain only letters and numbers
    - Not contain spaces or special characters

    Example:
    Input: "Hello #World this is a #greatpost!"
    Output: 'Hello <a href="/hashtag/world">#{world}</a> this is a #<a href="/hashtag/greatpost">#{greatpost}</a>!'
    """
    # Pattern matches # followed by letters/numbers only
    pattern = r"#([a-zA-Z0-9]+)"

    def replace_tag(match):
        tag = match.group(1)  # Get the tag without the #
        # Convert to lowercase for case-insensitive handling
        tag_lower = tag.lower()
        return f'<a href="/tags?tag={tag_lower}">#{tag}</a>'

    # Replace all hashtags with their link versions
    processed_text = re.sub(pattern, replace_tag, text)

    return processed_text


# Also generated by Claude AI
def process_urls(text):
    """
    Process text to convert URLs into clickable links.
    Matches URLs starting with http://, https://, or www.
    """
    # Pattern for URLs - matches http://, https://, or www.
    url_pattern = r"(https?://[^\s]+)|(www\.[^\s]+)"

    def replace_url(match):
        url = match.group(0)
        # Add https:// to www. urls if needed
        if url.startswith("www."):
            full_url = "https://" + url
        else:
            full_url = url
        return f'<a href="{full_url}" target="_blank">{url}</a>'

    # Replace URLs with clickable links
    processed_text = re.sub(url_pattern, replace_url, text)

    return processed_text


# Combined processor for both URLs and hashtags
def process_text(text):
    """Process text for both URLs and hashtags"""
    # First process URLs
    text = process_urls(text)
    # Then process hashtags
    text = process_hashtags(text)
    return text


ALLOWED_EXTENSIONS = {"png", "jpg", "jpeg", "gif"}


# function to check file extension
def allowed_file(filename):
    return "." in filename and filename.rsplit(".", 1)[1].lower() in ALLOWED_EXTENSIONS


# AWS S3 bucket connection
s3 = boto3.client(
    "s3",
    aws_access_key_id=os.getenv("AWS_ACCESS_KEY"),
    aws_secret_access_key=os.getenv("AWS_SECRET_ACCESS_KEY"),
)


# Upload image to AWS S3
def upload_file_to_s3(file, acl="public-read"):
    try:
        filename = secure_filename(file.filename)

        if not filename:
            return None

        # Check file extension
        if not allowed_file(filename):
            return None

        timestamp = datetime.now().strftime("%Y%m%d-%H%M%S")
        unique_filename = f"{timestamp}-{filename}"

        s3.upload_fileobj(
            file,
            os.getenv("AWS_BUCKET_NAME"),
            unique_filename,
            ExtraArgs={"ContentType": file.content_type},
        )

        # After upload file to s3 bucket, return image url
        return f"{os.getenv('AWS_DOMAIN')}{unique_filename}"

    except Exception as e:
        # This is a catch all exception, edit this part to fit your needs.
        print("Something Happened: ", e)
        return str(e)


def delete_file_from_s3(user_image):
    user = User.query.filter(
        User.id == session["user_id"], User.image == user_image
    ).first()
    if not user:
        return "User or image not found", 404

    # Parse the URL
    parsed_url = urlparse(user_image)
    # Get the path after the bucket name
    path_parts = parsed_url.path.split("/")

    # Remove empty strings and the first element (which is empty due to leading /)
    path_parts = [part for part in path_parts if part]

    # If the bucket name is in the path (like in virtual-hosted style URLs),
    # remove it from the path parts
    bucket_name = os.getenv("AWS_BUCKET_NAME")
    if path_parts[0] == bucket_name:
        path_parts.pop(0)

    # Join the remaining parts to form the key
    key = "/".join(path_parts)

    try:
        s3.delete_object(Bucket=bucket_name, Key=key)
        return True
    except Exception as e:
        print("Error Deleting File: ", e)
        return str(e)
