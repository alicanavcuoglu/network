import imghdr
import os
import re
from datetime import datetime
from functools import wraps
from typing import Literal
from urllib.parse import urlparse

import boto3
from botocore.config import Config
from flask import flash, redirect, session, url_for
from werkzeug.utils import secure_filename


# Login required
def login_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if "user_id" not in session:
            return redirect(url_for("auth.login"))
        return f(*args, **kwargs)

    return decorated_function


# Logout required
def logout_required(func):
    @wraps(func)
    def decorated_function(*args, **kwargs):
        if session.get("user_id"):
            flash("You are already authenticated.", "info")
            return redirect(url_for("main.feed"))
        return func(*args, **kwargs)

    return decorated_function


# """ EMAIL VERIFICATION """
# def generate_token(email):
#     serializer = URLSafeTimedSerializer(current_app.config["SECRET_KEY"])
#     return serializer.dumps(email, salt=current_app.config["SECURITY_PASSWORD_SALT"])


# def confirm_token(token, expiration=3600):
#     serializer = URLSafeTimedSerializer(current_app.config["SECRET_KEY"])
#     try:
#         email = serializer.loads(
#             token, salt=current_app.config["SECURITY_PASSWORD_SALT"], max_age=expiration
#         )
#         return email
#     except Exception:
#         return False

# def send_email(to, subject, template):
#     from app.extensions import dbmail
#     msg = Message(
#         subject,
#         recipients=[to],
#         html=template,
#         sender=current_app.config["MAIL_DEFAULT_SENDER"],
#     )
#     mail.send(msg)


def array_to_str(array):
    return ",".join(array)


def validate_image(stream):
    header = stream.read(512)
    stream.seek(0)
    format = imghdr.what(None, header)
    if not format:
        return None
    return "." + (format if format != "jpeg" else "jpg")


def create_notification_message(notification):
    sender_name = f"{notification.sender.name} {notification.sender.surname}"

    match notification.notification_type.value:
        case "friend_request":
            return f"{sender_name} sent you a friend request"
        case "friend_accepted":
            return f"{sender_name} accepted your friend request"
        case "post_like":
            return f"{sender_name} liked your post"
        case "post_comment":
            return f"{sender_name} commented on your post"
        case "post_share":
            return f"{sender_name} shared your post"
        case "comment_like":
            return f"{sender_name} liked your comment"
        # TODO: Add new notification message
        case _:
            return f"New notification from {sender_name}"


def create_notification_link(notification):
    match notification.notification_type.value:
        case "friend_request":
            return "/friends/requests"
        case "friend_accepted":
            return f"/profiles/{notification.sender.username}"
        case "post_like":
            return f"/posts/{notification.post_id}"
        case "post_comment":
            return f"/posts/{notification.post_id}#comment-{notification.comment_id}"
        case "post_share":
            return f"/posts/{notification.post_id}"
        case "comment_like":
            return f"/posts/{notification.post_id}#comment-{notification.comment_id}"
        # TODO: Add new notification link
        case _:
            return "#"


# Generated by Claude AI
def process_hashtags(text):
    """
    Process text to convert hashtags into clickable links.
    Hashtags must:
    - Start with #
    - Contain only letters and numbers
    - Not contain spaces or special characters

    Example:
    Input: "Hello #World this is a #greatpost!"
    Output: 'Hello <a href="/hashtag/world">#{world}</a> this is a #<a href="/hashtag/greatpost">#{greatpost}</a>!'
    """
    # Pattern matches # followed by letters/numbers only
    pattern = r"#([a-zA-Z0-9]+)"

    def replace_tag(match):
        tag = match.group(1)  # Get the tag without the #
        # Convert to lowercase for case-insensitive handling
        tag_lower = tag.lower()
        return f'<a href="/tags?tag={tag_lower}">#{tag}</a>'

    # Replace all hashtags with their link versions
    processed_text = re.sub(pattern, replace_tag, text)

    return processed_text


# Also generated by Claude AI
def process_urls(text):
    """
    Process text to convert URLs into clickable links.
    Matches URLs starting with http://, https://, or www.
    """
    # Pattern for URLs - matches http://, https://, or www.
    url_pattern = r"(https?://[^\s]+)|(www\.[^\s]+)"

    def replace_url(match):
        url = match.group(0)
        # Add https:// to www. urls if needed
        if url.startswith("www."):
            full_url = "https://" + url
        else:
            full_url = url
        return f'<a href="{full_url}" target="_blank">{url}</a>'

    # Replace URLs with clickable links
    processed_text = re.sub(url_pattern, replace_url, text)

    return processed_text


# Combined processor for both URLs and hashtags
def process_text(text):
    """Process text for both URLs and hashtags"""
    # First process URLs
    text = process_urls(text)
    # Then process hashtags
    text = process_hashtags(text)
    return text


ALLOWED_EXTENSIONS = {"png", "jpg", "jpeg", "gif"}


# function to check file extension
def allowed_file(filename):
    return "." in filename and filename.rsplit(".", 1)[1].lower() in ALLOWED_EXTENSIONS


# AWS S3 bucket connection
s3 = boto3.client(
    "s3",
    aws_access_key_id=os.getenv("AWS_ACCESS_KEY"),
    aws_secret_access_key=os.getenv("AWS_SECRET_ACCESS_KEY"),
    config=Config(signature_version="s3v4"),
)

# Get presigned url
def get_presigned_url(key, expires_in=3600):
    try:
        url = s3.generate_presigned_url(
            'get_object',
            Params={'Bucket': os.getenv("AWS_BUCKET_NAME"), 'Key': key},
            ExpiresIn=expires_in
        )
        return url
    except Exception as e:
        print("Error generating URL:", e)
        return None


# Upload image to AWS S3
def upload_file_to_s3(
    file, folder: Literal["user-image", "group-image"] = "user-image"
):
    try:
        filename = secure_filename(file.filename)

        if not filename or not allowed_file(filename):
            return None


        timestamp = datetime.now().strftime("%Y%m%d-%H%M%S")
        unique_filename = f"{folder}/{timestamp}-{filename}"

        s3.upload_fileobj(
            file,
            os.getenv("AWS_BUCKET_NAME"),
            unique_filename,
            ExtraArgs={"ContentType": file.content_type, "ACL": "private"},
        )

        # After upload file to s3 bucket, return filename
        return unique_filename

    except Exception as e:
        # This is a catch all exception, edit this part to fit your needs.
        print("Something Happened: ", e)
        return str(e)


# Delete user image from AWS S3
def delete_file_from_s3(key):
   try:
       s3.delete_object(
           Bucket=os.getenv("AWS_BUCKET_NAME"),
           Key=key
       )
       return True
   except Exception as e:
       print("Error Deleting File:", e)
       return str(e)